### 1. Majority Element-I
Given an integer array nums of size n, return the majority element of the array.

The majority element of an array is an element that appears more than n/2 times in the array. The array is guaranteed to have a majority element.

```
Better [ T: O(NlogN) ] [ S: O(N) ]
```

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int majority = nums.size()/2;
        map<int,int> ans; 
        for (int i=0; i<nums.size(); i++){
            ans[nums[i]]++;
            if (ans[nums[i]] > majority){
                return nums[i];
            }
        }
        return -1;
    }
};
```

```
Optimal: [ T: O(N) ] [ S: O(1) ]
```

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int mj = nums[0];
        int mj_count = 0;
        for (int i=0; i<nums.size(); i++){
            if (mj_count == 0){
                mj = nums[i];
                mj_count = 0;
            }
            if (nums[i] == mj){
                mj_count++;
            } else {
                mj_count--;
            }
        }
        return mj;
    }
};
```

### 2. Majority Element-II
Given an integer array nums of size n. Return all elements which appear more than n/3 times in the array. The output can be returned in any order.

```
Better: Using Map
```

```
class Solution {
public:
    vector<int> majorityElementTwo(vector<int>& nums) {
        set<int> ans;
        int majority = nums.size() / 3;
        map<int, int> mapper;
        for (int i=0; i<nums.size(); i++){
            mapper[nums[i]]++;
            if (mapper[nums[i]] > majority){
                ans.insert(nums[i]);
            }
        }
        vector<int> answer(ans.begin(), ans.end());
        return answer;
    }
};
```

```
Optimal: 
```

```
class Solution {
public:
    // Function to find majority elements in an array
    vector<int> majorityElementTwo(vector<int>& nums) {
        int ele1 = INT_MIN;
        int ele2 = INT_MIN;
        int c1 = 0;
        int c2 = 0;
        for (int i=0; i<nums.size(); i++){
            if (c1 == 0 && nums[i] != ele2){
                ele1 = nums[i];
                c1 = 1;
            } else if (c2 == 0 && nums[i] != ele1){
                ele2 = nums[i];
                c2 = 1;
            } else if (nums[i] == ele1){
                c1++;
            } else if (nums[i] == ele2){
                c2++;
            } else {
                c1--;
                c2--;
            }
        }

        int majority = nums.size() / 3 + 1;
        c1 = 0;
        c2 = 0;
        for (int i=0; i<nums.size(); i++){
            if (nums[i] == ele1){
                c1++;
            } else if (nums[i] == ele2){
                c2++;
            }
        }

        vector<int> ans;
        if (c1 >= majority){
            ans.push_back(ele1);
        } 
        if (c2 >= majority && ele1 != ele2){
            ans.push_back(ele2);
        }

        return ans;
    }
};
```

### 3. Find the repeating and missing number
Given an integer array nums of size n containing values from [1, n] and each value appears exactly once in the array, except for A, which appears twice and B which is missing.

Return the values A and B, as an array of size 2, where A appears in the 0-th index and B in the 1st index.

```
Better [ T: O(N) ] [ S: O(N) ]
```

```
class Solution {
public:
    vector<int> findMissingRepeatingNumbers(vector<int> nums) {
        sort(nums.begin(), nums.end());
        vector<int> ans;
        map<int, int> m;
        int missing = INT_MIN;
        int dup = 0;
        for (int i=0; i<nums.size(); i++){
            m[nums[i]]++;
            if (nums[i] != i+1 && m.find(i+1) == m.end()){
                missing = i+1;
            }
            if (m[nums[i]] == 2){
                dup = nums[i];
            }
        }
        ans.push_back(dup);
        ans.push_back(missing);
        return ans;
    }
};
```

```
Optimal: Math 
```

```
class Solution {
public:
    vector<int> findMissingRepeatingNumbers(vector<int> nums) {
        int n = nums.size();
        long long sumOfN = (n * (n+1))/2;
        long long sumOfNSqaure = (n * (n+1) * (2*n + 1)) /6;

        long long SumofArray= 0, SumofSquareArray = 0;
        for (int i=0; i<nums.size(); i++){
            SumofArray += nums[i];
            SumofSquareArray += (long long)nums[i] * (long long)nums[i];
        }

        long long val1 = SumofArray - sumOfN;
        long long val2 = SumofSquareArray - sumOfNSqaure;
        val2 = val2 / val1;

        long long x = (val1+val2) / 2;
        long long y = x - val1;
        return {(int)x, (int)y};
    }
};
```

### 4. Count Inversions
Given an integer array nums. Return the number of inversions in the array.

Two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.

1. It indicates how close an array is to being sorted.
2. A sorted array has an inversion count of 0.
3. An array sorted in descending order has maximum inversion.

```
Bruteforce
```

```
class Solution {
public:
   long long int numberOfInversions(vector<int> nums) {
        int ans = 0;
        for (int i=0; i<nums.size(); i++){
            for (int j=i; j<nums.size(); j++){
                if (nums[i] > nums[j] && i < j){
                    ans+=1;
                }
            }
        }
        return ans;
    }
};
```

```
Optimal
```

```
```